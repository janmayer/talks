I would like to give a small tutorial or workshop on HTTPS, TLS, and certificates. What should I talk about in detail, what exercises should I plan, and how should I structure this? We working with Python if possible.
--------------------------
Great! Here's a rough outline of what you can cover in your tutorial or workshop on HTTPS, TLS, and certificates, along with some exercises you can plan:

Introduction to HTTPS
What is HTTPS and why is it important?
Overview of the HTTP protocol and its limitations
How HTTPS improves security and privacy
Overview of TLS
What is TLS and how does it work?
How TLS provides encryption and authentication
TLS handshake and key exchange
Certificates
What are certificates and why are they important?
Overview of certificate authorities (CAs)
How certificates are issued, validated, and revoked
Overview of certificate types (e.g., DV, OV, EV)
Python and HTTPS
How to use Python to make HTTPS requests (e.g., requests library)
How to verify SSL/TLS certificates in Python
Examples of using Python to interact with HTTPS APIs
Exercises
Write a Python script that makes an HTTPS request and validates the certificate
Set up a simple HTTPS server using Python and test it with a client
Explore the certificate chain of a website using Python
Conclusion
Recap of key concepts
Resources for further learning

Here's a possible structure for your tutorial:

Introduction (5-10 minutes)
HTTPS (20-30 minutes)
TLS (20-30 minutes)
Certificates (20-30 minutes)
Python and HTTPS (30-40 minutes)
Exercises (30-40 minutes)
Conclusion (5-10 minutes)

You can adjust the timing based on the level of detail you want to cover and the needs of your audience. You can also add more exercises or examples depending on the time available and the level of proficiency of your audience.

Good luck with your tutorial or workshop!
--------------------------
Okay, I would like to shorten the https section, and instead add something about authentication, authorization, and encryption.

Also, I would like a short point on Cipher Suites where appropriate
--------------------------
Sure, here's an updated outline that covers authentication, authorization, encryption, and cipher suites:

Introduction to HTTPS
What is HTTPS and why is it important?
Overview of the HTTP protocol and its limitations
How HTTPS improves security, privacy, authentication, authorization, and encryption
Overview of TLS
What is TLS and how does it work?
How TLS provides encryption, authentication, and authorization
TLS handshake and key exchange
Overview of cipher suites and how they affect security and performance
Certificates
What are certificates and why are they important?
Overview of certificate authorities (CAs)
How certificates are issued, validated, and revoked
Overview of certificate types (e.g., DV, OV, EV)
Python and HTTPS
How to use Python to make HTTPS requests (e.g., requests library)
How to verify SSL/TLS certificates in Python
Examples of using Python to interact with HTTPS APIs
Exercises
Write a Python script that makes an HTTPS request and validates the certificate
Set up a simple HTTPS server using Python and test it with a client
Explore the certificate chain of a website using Python
Conclusion
Recap of key concepts
Resources for further learning

Here's how you can structure your tutorial or workshop:

Introduction (5-10 minutes)
HTTPS, authentication, authorization, and encryption (20-30 minutes)
TLS and cipher suites (20-30 minutes)
Certificates (20-30 minutes)
Python and HTTPS (30-40 minutes)
Exercises (30-40 minutes)
Conclusion (5-10 minutes)

Again, feel free to adjust the timing and content to fit your audience and goals. Good luck with your tutorial or workshop!
--------------------------
I would like to create slides from Markdown. Could you genereate Markdown slides for the first section?
--------------------------
Sure, here's an example of what the Markdown slides for the first section of your tutorial could look like:

yaml
Copy code
# Introduction to HTTPS

---

## What is HTTPS and why is it important?

- HTTPS stands for Hypertext Transfer Protocol Secure
- It is an encrypted version of the HTTP protocol
- It uses SSL/TLS to secure the connection between the client and server
- HTTPS provides confidentiality, integrity, and authenticity
- It is important for protecting sensitive information (e.g., passwords, credit card numbers)

---

## Overview of the HTTP protocol and its limitations

- HTTP is an unencrypted protocol for transmitting data over the web
- It is stateless and connectionless, meaning that each request and response is independent of others
- It is vulnerable to eavesdropping, tampering, and other attacks
- HTTP is suitable for non-sensitive information (e.g., public content, news articles)

---

## How HTTPS improves security, privacy, authentication, authorization, and encryption

- HTTPS provides end-to-end encryption, meaning that data is encrypted from the client to the server and vice versa
- It provides server authentication, meaning that the client can verify the identity of the server
- It provides client authentication, meaning that the server can verify the identity of the client (optional)
- It provides access control, meaning that the server can restrict access to specific resources based on the client's credentials
- HTTPS is the recommended protocol for transmitting sensitive information over the web



You can customize the content and formatting of the slides based on your needs and preferences. You can use a tool like Reveal.js, Remark.js, or Marp to convert the Markdown slides into HTML or PDF format.
--------------------------
Ok, for the next slides about TLS be much more technical and in-depth.
--------------------------
Sure, here's an example of what the Markdown slides for the TLS section of your tutorial could look like, with more technical and in-depth information:

yaml
Copy code
# Overview of TLS

---

## What is TLS and how does it work?

- TLS (Transport Layer Security) is a protocol for securing communication over the internet
- It is the successor to SSL (Secure Sockets Layer) protocol
- TLS provides confidentiality, integrity, and authenticity of data exchanged between the client and server
- It uses a combination of symmetric and asymmetric encryption, digital certificates, and trust mechanisms to achieve its security goals

---

## How TLS provides encryption, authentication, and authorization

- Encryption: TLS uses symmetric encryption to encrypt data and asymmetric encryption to securely exchange the symmetric keys between the client and server
- Authentication: TLS provides server authentication, which enables the client to verify the identity of the server using a digital certificate issued by a trusted third party called a Certificate Authority (CA)
- Authorization: TLS provides access control, which enables the server to restrict access to specific resources based on the client's credentials

---

## TLS handshake and key exchange

- The TLS handshake is a process of establishing a secure connection between the client and server
- It involves the following steps:
  1. Client hello: the client sends a hello message to the server, specifying its supported TLS version and cipher suites
  2. Server hello: the server responds with a hello message, selecting the TLS version and cipher suite that both parties support
  3. Server certificate: the server sends its digital certificate to the client, which includes the server's public key and other information about the certificate
  4. Client key exchange: the client generates a random key and encrypts it with the server's public key, which is sent to the server
  5. Server key exchange (optional): if the server requests client authentication, it sends its public key to the client for encryption of client's private key
  6. Change cipher spec: both parties agree to switch to the encrypted mode using the negotiated symmetric key
  7. Finished: both parties send a message to confirm that the handshake is complete

---

## Overview of cipher suites and how they affect security and performance

- A cipher suite is a combination of cryptographic algorithms used for encrypting data in TLS
- Cipher suites consist of a key exchange algorithm, a symmetric encryption algorithm, and a message authentication code (MAC) algorithm
- The choice of cipher suite affects the security and performance of TLS
- Some cipher suites provide better security but have higher computational overhead, while others are faster but less secure
- It is recommended to use modern cipher suites with perfect forward secrecy (PFS) and authenticated encryption (AE) for better security and privacy


Again, you can customize the content and formatting of the slides based on your needs and preferences. You can also add diagrams or animations to help illustrate the concepts.
--------------------------
On the slide "## How TLS provides encryption, authentication, and authorization", are you sure that is correct? How does TLS provide access control?
--------------------------
You're right, I apologize for the mistake. TLS does not provide access control by itself. Access control is typically implemented at the application layer, such as using usernames and passwords or other authentication mechanisms.

Instead, TLS provides the confidentiality, integrity, and authenticity of data exchanged between the client and server. I'll update the slide to reflect this:

sql
Copy code
## How TLS provides encryption, authentication, and data integrity

- Encryption: TLS uses symmetric encryption to encrypt data and asymmetric encryption to securely exchange the symmetric keys between the client and server
- Authentication: TLS provides server authentication, which enables the client to verify the identity of the server using a digital certificate issued by a trusted third party called a Certificate Authority (CA)
- Data integrity: TLS provides data integrity, which ensures that the data exchanged between the client and server has not been tampered with or modified during transmission

--------------------------
Okay! Also about mutual TLS: How does the procedure look like if client certificates are required?
--------------------------
Sure, here's an example of what the mutual TLS (mTLS) handshake would look like if client certificates are required:

Client sends a ClientHello message to the server, including a list of supported cipher suites and a CertificateRequest message indicating that it wants the server to request a client certificate.

Server responds with a ServerHello message, selecting the cipher suite and TLS version to use. If the server requires a client certificate, it sends a CertificateRequest message to the client.

Client sends a Certificate message, containing its own certificate, to the server.

Client sends a ClientKeyExchange message, containing the client's public key encrypted with the server's public key.

Client sends a CertificateVerify message, which is a digitally signed message that includes the client's certificate and a hash of all preceding handshake messages. This verifies that the client possesses the private key corresponding to the public key in the client's certificate.

Client sends a ChangeCipherSpec message, indicating that all subsequent messages will be encrypted with the negotiated symmetric key.

Client sends a Finished message, which is a hash of all preceding handshake messages encrypted with the negotiated symmetric key.

Server sends a Certificate message, containing its own certificate, to the client.

Server sends a ServerKeyExchange message, containing the server's public key encrypted with the client's public key, if required by the selected cipher suite.

Server sends a CertificateVerify message, which is a digitally signed message that includes the server's certificate and a hash of all preceding handshake messages. This verifies that the server possesses the private key corresponding to the public key in the server's certificate.

Server sends a ChangeCipherSpec message, indicating that all subsequent messages will be encrypted with the negotiated symmetric key.

Server sends a Finished message, which is a hash of all preceding handshake messages encrypted with the negotiated symmetric key.

Once the mTLS handshake is complete, both the client and server have authenticated each other and possess the necessary keys to securely exchange data. The data is encrypted using the symmetric key established during the handshake and protected against tampering using message authentication codes.
--------------------------
Okay. Please expand the section about cipher suites and key exchanges with more detailed explanations.
--------------------------
Sure, here's an expanded section about cipher suites and key exchanges in TLS:

Cipher Suites

A cipher suite is a combination of cryptographic algorithms used to secure the communication between the client and server. It specifies the key exchange algorithm, the encryption algorithm, and the message authentication code (MAC) algorithm to use. When a client and server negotiate a cipher suite, they agree on the algorithms to use for these three functions.

TLS provides a range of cipher suites to choose from, which are defined by the TLS protocol and can be extended by individual implementations. Some examples of commonly used cipher suites are:

TLS_RSA_WITH_AES_256_GCM_SHA384: This cipher suite uses RSA key exchange, AES-256 encryption in Galois/Counter Mode (GCM), and SHA-384 as the MAC algorithm.
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: This cipher suite uses Elliptic Curve Diffie-Hellman Ephemeral (ECDHE) key exchange, RSA authentication, AES-128 encryption in Cipher Block Chaining (CBC) mode, and SHA-1 as the MAC algorithm.
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: This cipher suite uses Diffie-Hellman Ephemeral (DHE) key exchange, RSA authentication, AES-128 encryption in GCM mode, and SHA-256 as the MAC algorithm.

Different cipher suites have different strengths and weaknesses, and the choice of cipher suite should be based on the security requirements of the communication and the capabilities of the client and server. For example, some cipher suites may not be supported by older or less powerful devices.

Key Exchanges

The key exchange algorithm is a fundamental component of the cipher suite, as it is used to securely establish the symmetric key that will be used to encrypt the data exchanged between the client and server. There are two main types of key exchange algorithms used in TLS:

Asymmetric key exchange: In an asymmetric key exchange, also known as public key cryptography, the client and server each have a public-private key pair. The client and server exchange their public keys, and each party uses their own private key to decrypt the other party's public key. Once each party has the other party's public key, they can securely exchange a shared secret key using that public key. The shared secret key is then used for symmetric encryption and decryption of data. Examples of asymmetric key exchange algorithms used in TLS include RSA and Elliptic Curve Cryptography (ECC).

Symmetric key exchange: In a symmetric key exchange, both the client and server share a secret key that is used for both encryption and decryption of data. The key is generated independently by each party, and then securely exchanged between them. Examples of symmetric key exchange algorithms used in TLS include Diffie-Hellman (DH) and Elliptic Curve Diffie-Hellman (ECDH).

TLS provides a range of key exchange algorithms to choose from, including both asymmetric and symmetric algorithms. The choice of key exchange algorithm should be based on the security requirements of the communication and the capabilities of the client and server. For example, asymmetric key exchange algorithms provide stronger security guarantees but require more computational resources than symmetric key exchange algorithms.
--------------------------
Can you make that into a markdown slide?
--------------------------
Sure, here's the expanded section about cipher suites and key exchanges in markdown slide format:

Cipher Suites
A cipher suite is a combination of cryptographic algorithms used to secure the communication between the client and server.
It specifies the key exchange algorithm, the encryption algorithm, and the message authentication code (MAC) algorithm to use.
TLS provides a range of cipher suites to choose from.
Different cipher suites have different strengths and weaknesses, and the choice of cipher suite should be based on the security requirements of the communication and the capabilities of the client and server.
Examples of Cipher Suites
TLS_RSA_WITH_AES_256_GCM_SHA384: RSA key exchange, AES-256 encryption in Galois/Counter Mode (GCM), and SHA-384 MAC.
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: ECDHE key exchange, RSA authentication, AES-128 encryption in Cipher Block Chaining (CBC) mode, and SHA-1 MAC.
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: DHE key exchange, RSA authentication, AES-128 encryption in GCM mode, and SHA-256 MAC.
Key Exchanges
The key exchange algorithm is a fundamental component of the cipher suite.
It is used to securely establish the symmetric key that will be used to encrypt the data exchanged between the client and server.
There are two main types of key exchange algorithms used in TLS: asymmetric and symmetric.
Asymmetric Key Exchange
In an asymmetric key exchange, also known as public key cryptography, the client and server each have a public-private key pair.
The client and server exchange their public keys, and each party uses their own private key to decrypt the other party's public key.
Once each party has the other party's public key, they can securely exchange a shared secret key using that public key.
The shared secret key is then used for symmetric encryption and decryption of data.
Examples of asymmetric key exchange algorithms used in TLS include RSA and Elliptic Curve Cryptography (ECC).
Symmetric Key Exchange

In a symmetric key exchange, both the client and server share a secret key that is used for both encryption and decryption of data.

The key is generated independently by each party, and then securely exchanged between them.

Examples of symmetric key exchange algorithms used in TLS include Diffie-Hellman (DH) and Elliptic Curve Diffie-Hellman (ECDH).

The choice of key exchange algorithm should be based on the security requirements of the communication and the capabilities of the client and server.
--------------------------
Now, generate the markdown slides for the Certificates section
--------------------------
Sure, here's the markdown slides for the Certificates section:

Certificates
A certificate is a digital document that provides authentication and enables secure communication over a network.
In TLS, certificates are used to authenticate the identity of the server and, optionally, the client.
Certificates are issued by Certificate Authorities (CAs), which are trusted third-party entities that verify the identity of the certificate holder.
Structure of a Certificate
A certificate contains several pieces of information:
The name of the entity that the certificate identifies (e.g., the server's domain name)
The public key of the entity
The digital signature of the CA that issued the certificate
The validity period of the certificate
Any other relevant information, such as the CA's name and the certificate's serial number
Types of Certificates
There are two main types of certificates used in TLS: server certificates and client certificates.
Server Certificates
A server certificate is used to authenticate the identity of the server to the client.
It contains the server's public key, which is used to establish a secure connection with the client.
Server certificates are issued by CAs that are trusted by the client.
Client Certificates
A client certificate is used to authenticate the identity of the client to the server.
It contains the client's public key, which is used to establish a secure connection with the server.
Client certificates are not as commonly used as server certificates, and are typically only used in situations where a higher level of security is required.
Certificate Chains
A certificate chain is a sequence of certificates that link the server's certificate to a trusted root CA.
The server's certificate is typically issued by an intermediate CA, which in turn is issued by a root CA.
When a client connects to a server, it verifies the authenticity of the server's certificate by checking the digital signature of the intermediate CA and root CA.
Certificate Revocation
Sometimes, a certificate needs to be revoked before its expiration date (e.g., if the private key is compromised).
Certificate Revocation Lists (CRLs) are used to provide a list of revoked certificates.
Online Certificate Status Protocol (OCSP) is an alternative to CRLs, which provides real-time revocation status checking.
Self-Signed Certificates
A self-signed certificate is a certificate that is signed by the same entity whose identity it certifies.
Self-signed certificates are not trusted by default, but can be manually trusted by adding the self-signed certificate to the list of trusted certificates on the client or server.
Self-signed certificates are often used in development or testing environments.
--------------------------
I also need a slide on private and public keys, plus symmetric and asymetric encryption
--------------------------
Sure, here's the markdown slide:

Private and Public Keys, Symmetric and Asymmetric Encryption
Private and Public Keys
Public key cryptography uses a pair of keys to encrypt and decrypt data: a public key and a private key.
The public key is shared freely and used to encrypt data.
The private key is kept secret and used to decrypt data.
As the name suggests, public key cryptography is designed to allow anyone to encrypt data, but only the owner of the private key to decrypt it.
Symmetric Encryption
Symmetric encryption uses the same key to encrypt and decrypt data.
Both the sender and the recipient must have the same key.
Symmetric encryption is generally faster than public key cryptography but requires a secure method of exchanging keys.
Asymmetric Encryption
Asymmetric encryption uses different keys to encrypt and decrypt data: a public key and a private key.
The public key can be freely shared and used to encrypt data.
The private key is kept secret and used to decrypt data.
Asymmetric encryption is generally slower than symmetric encryption but does not require a secure method of exchanging keys.
How TLS Uses Encryption
TLS uses a combination of symmetric and asymmetric encryption.
When a client connects to a server, they negotiate a shared symmetric key that will be used for the remainder of the session.
This key is exchanged using asymmetric encryption to ensure that it cannot be intercepted or modified.
Once the symmetric key has been established, all data transmitted between the client and server is encrypted using symmetric encryption.
--------------------------
Okay, now for some examples. Please generate a script in python using the cryptography package to generate private-public stuff to be used as a certificate authority.
--------------------------
Sure, here's an example Python script using the cryptography package to generate a private-public key pair to be used as a certificate authority:

python
Copy code
from cryptography.hazmat.primitives.asymmetric import (
    rsa,
    padding,
    utils,
)
from cryptography.hazmat.primitives import serialization, hashes


# Generate a private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

# Serialize the private key and write it to a file
with open("ca_private_key.pem", "wb") as f:
    f.write(
        private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
    )

# Extract the public key from the private key and serialize it
public_key = private_key.public_key()
public_key_bytes = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo,
)

# Write the public key to a file
with open("ca_public_key.pem", "wb") as f:
    f.write(public_key_bytes)


This code generates a 2048-bit RSA private key, serializes it to the PEM format, and writes it to a file called ca_private_key.pem. It then extracts the public key from the private key, serializes it to the PEM format, and writes it to a file called ca_public_key.pem.

Note that this script only generates the private-public key pair for the certificate authority, and does not cover the full process of issuing and signing certificates.
--------------------------
Okay, now generate a certificate and csr to be used in the server, and sign that csr with that authority.
--------------------------
Sure, here's an example Python script using the cryptography package to generate a certificate signing request (CSR) for a server and then sign it with a certificate authority:

python
Copy code
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.x509 import (
    Name,
    SubjectAlternativeName,
    BasicConstraints,
    CertificateBuilder,
)

# Load the CA private key and certificate
with open("ca_private_key.pem", "rb") as f:
    ca_private_key = load_pem_private_key(
        f.read(),
        password=None,
    )

with open("ca_public_key.pem", "rb") as f:
    ca_public_key = load_pem_public_key(
        f.read(),
    )

# Generate a private key for the server
server_private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
)

# Generate a certificate signing request (CSR) for the server
csr = x509.CertificateSigningRequestBuilder().subject_name(Name([
    x509.NameAttribute(NameOID.COMMON_NAME, 'example.com'),
])).add_extension(
    SubjectAlternativeName([x509.DNSName('example.com')]), critical=False,
).sign(server_private_key, hashes.SHA256())

# Sign the CSR with the CA private key to generate a server certificate
server_cert_builder = (
    CertificateBuilder()
    .subject_name(csr.subject)
    .issuer_name(
        ca_public_key.public_bytes(
            Encoding.DER, x509.Name(
                [
                    x509.NameAttribute(
                        NameOID.COMMON_NAME, 'Certificate Authority'
                    )
                ]
            ),
        )
    )
    .public_key(csr.public_key())
    .serial_number(x509.random_serial_number())
    .not_valid_before(x509.datetime.datetime.utcnow())
    .not_valid_after(x509.datetime.datetime.utcnow() + x509.timedelta(days=365))
    .add_extension(
        x509.BasicConstraints(ca=False, path_length=None), critical=True
    )
    .add_extension(
        x509.AuthorityKeyIdentifier.from_issuer_public_key(
            ca_public_key
        ),
        critical=False,
    )
    .add_extension(
        x509.SubjectKeyIdentifier.from_public_key(csr.public_key()),
        critical=False,
    )
)

server_cert = server_cert_builder.sign(
    private_key=ca_private_key,
    algorithm=hashes.SHA256(),
    backend=None,
)

# Write the server private key, certificate signing request (CSR),
# and server certificate to files
with open("server_private_key.pem", "wb") as f:
    f.write(
        server_private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
    )

with open("server_csr.pem", "wb") as f:
    f.write(csr.public_bytes(Encoding.PEM))

with open("server_certificate.pem", "wb") as f:
    f.write(server_cert.public_bytes(Encoding.PEM))


This code loads the private key and public key for the certificate authority generated in the previous example. It then generates a private key for the server and creates a certificate signing request (CSR) for that private key, using the x509.CertificateSigningRequestBuilder() class.

It then signs the CSR with the CA private key to generate a server certificate using the
--------------------------
Okay, now I need a script that starts a python webserver that uses this certificate.
--------------------------
Sure, here's an example script that uses the http.server module to start a web server with the generated certificate:

python
Copy code
import http.server
import ssl

certfile = "server.crt"
keyfile = "server.key"
port = 8443

class HTTPHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"Hello, world!")

httpd = http.server.HTTPServer(('localhost', port), HTTPHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile=certfile, keyfile=keyfile, server_side=True)

print("Serving on https://localhost:{}".format(port))
httpd.serve_forever()


Make sure to replace server.crt and server.key with the paths to your generated certificate and private key files, respectively.

This script will serve files from the current directory on port 8443 using HTTPS with the provided certificate and key. When you run the script, you should be able to visit https://localhost:8443 in your web browser and see "Hello, world!" displayed in the browser.
--------------------------
How would a self-signed certificate be created in python?
--------------------------
Here's an example Python script that uses the cryptography package to generate a self-signed certificate:

python
Copy code
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID
from datetime import datetime, timedelta

# Generate a new private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)

# Create a self-signed certificate
subject = issuer = x509.Name([
    x509.NameAttribute(NameOID.COMMON_NAME, "localhost")
])
not_valid_before = datetime.utcnow()
not_valid_after = not_valid_before + timedelta(days=365)
builder = x509.CertificateBuilder().subject_name(
    subject
).issuer_name(
    issuer
).public_key(
    private_key.public_key()
).serial_number(
    x509.random_serial_number()
).not_valid_before(
    not_valid_before
).not_valid_after(
    not_valid_after
).add_extension(
    x509.BasicConstraints(ca=False, path_length=None), critical=True,
).add_extension(
    x509.SubjectAlternativeName([x509.DNSName("localhost")]), critical=False,
).add_extension(
    x509.KeyUsage(
        digital_signature=True, key_encipherment=True, content_commitment=False,
        data_encipherment=False, key_agreement=False, key_cert_sign=False, crl_sign=False,
        encipher_only=False, decipher_only=False,
    ),
    critical=True,
).add_extension(
    x509.ExtendedKeyUsage(
        [x509.ExtendedKeyUsageOID.SERVER_AUTH],
    ),
    critical=False,
).sign(private_key, hashes.SHA256())

# Write the private key and certificate to disk
with open("server.key", "wb") as key_file:
    key_file.write(
        private_key.private_bytes(
            encoding=x509.Encoding.PEM,
            format=x509.PrivateFormat.PKCS8,
            encryption_algorithm=x509.NoEncryption(),
        )
    )

with open("server.crt", "wb") as cert_file:
    cert_file.write(builder.public_bytes(encoding=x509.Encoding.PEM))


This script generates a new RSA private key with a key size of 2048 bits, and uses that key to create a self-signed certificate that is valid for one year. The certificate is saved to a file called server.crt, and the corresponding private key is saved to server.key.

Keep in mind that since this is a self-signed certificate, it will not be trusted by most web browsers by default. You can add the certificate to your browser's trusted certificate store to avoid security warnings.
--------------------------
NEW